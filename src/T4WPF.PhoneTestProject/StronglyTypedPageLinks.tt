<#@ template language="C#" hostspecific="true" debug="true" #>
<#@ output extension=".generated.cs" #>

<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>

<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>

<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>


<# // To debug, uncomment the next two lines !! 
//System.Diagnostics.Debugger.Launch();
//System.Diagnostics.Debugger.Break();

// get current project 
// read project file
IServiceProvider hostServiceProvider = (IServiceProvider)Host;
EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
if (dte == null) {
	throw new Exception("Could not get IDE instance - try restarting Visual Studio");
}
	
EnvDTE.ProjectItem templateProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
CurrentProject = templateProjectItem.ContainingProject;

// traverse through directory to get files
string currentDirectory = Path.GetDirectoryName(CurrentProject.FullName);
PageDirectory currentDir = GeneratePageLinksForDirectory(currentDirectory);
#>


// <autogenerated>
// Note: This file was autogenerated by a tool
// If you modify this file, changes will be lost after recompilation.
// </autogenerated>

using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.Reflection;
namespace <#=TryDetectProjectNamespace()#> {
	/// <summary>
    /// Represents the navigation to a page. This class contains navigation links to the root project and any project items below.
    /// </summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute]
	[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
	public sealed class <#=PageClassName#> : IEquatable<<#=PageClassName#>> {
        private readonly string path;

        /// <summary>
        /// Initializes a new instance of the <see cref="<#=PageClassName#>"/> class.
        /// </summary>
        /// <param name="path">The path.</param>
        internal <#=PageClassName#>(string path) {
            this.path = path;
        }

        /// <summary>
        /// Determines whether the specified <see cref="<#=PageClassName#>"/> is equal to this instance.
        /// </summary>
        /// <param name="other">The <see cref="<#=PageClassName#>"/> to compare with this instance.</param>
        /// <returns>
        ///   <c>true</c> if the specified <see cref="<#=PageClassName#>"/> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
		[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public bool Equals (<#=PageClassName#> other) {
            if (ReferenceEquals(null, other)) {
                return false;
            }
            if (ReferenceEquals(this, other)) {
                return true;
            }
            return Equals(other.path, this.path);
        }

        /// <summary>
        /// Determines whether the specified <see cref="System.Object"/> is equal to this instance.
        /// </summary>
        /// <param name="obj">The <see cref="System.Object"/> to compare with this instance.</param>
        /// <returns>
        ///   <c>true</c> if the specified <see cref="System.Object"/> is equal to this instance; otherwise, <c>false</c>.
        /// </returns>
		[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public override bool Equals (object obj) {
            if (ReferenceEquals(null, obj)) {
                return false;
            }
            if (ReferenceEquals(this, obj)) {
                return true;
            }
            if (!(obj is <#=PageClassName#>)) {
                return false;
            }
            return Equals((<#=PageClassName#>) obj);
        }

        /// <summary>
        /// Returns a hash code for this instance.
        /// </summary>
        /// <returns>
        /// A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
        /// </returns>
		[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
        public override int GetHashCode() {
            return (this.path != null ? this.path.GetHashCode() : 0);
        }

		/// <summary>Returns the path this object represents</summary>
		[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
		public override string ToString() {
			return this.path;
		}

		/// <summary>Hide the member from IntelliSense</summary>
		[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
		public new Type GetType() { return base.GetType(); }

        /// <summary>
        /// Returns a <see cref="<#=PageClassName#>"/> object a specified query string attached. Each other element of the parameters is a parameter and value
        /// </summary>
        /// <param name="queryParameters">The query parameters.</param>
        /// <returns></returns>
        public <#=PageClassName#> WithQuery(IDictionary<string,object> queryParameters) {
            if (queryParameters == null) {
                return this;
            }

            StringBuilder query = new StringBuilder();
            foreach (KeyValuePair<string, object> queryParameter in queryParameters) {
                string key = queryParameter.Key != null ? Uri.EscapeDataString(queryParameter.Key.ToString()) : String.Empty;
                object valObject = queryParameter.Value;
                string val = valObject != null ? Uri.EscapeDataString(valObject.ToString()) : String.Empty;

                query.Append(key);
                query.Append('=');
                query.Append(val);
                query.Append('&');
            }

            return WithQuery(query.ToString());
        }

        /// <summary>
        /// Returns a <see cref="<#=PageClassName#>"/> object a specified query string attached. Each other element of the parameters is a parameter and value
        /// </summary>
        /// <param name="queryParameters">The query parameters.</param>
        /// <returns></returns>
        public <#=PageClassName#> WithQuery(params object[] queryParameters) {
            if (queryParameters == null) {
                return this;
            }

            StringBuilder query = new StringBuilder();
            for (int i = 1; i < queryParameters.Length; i+=2) {
                object keyObject = queryParameters [0];
                string key = keyObject != null ? Uri.EscapeDataString(keyObject.ToString()) : String.Empty;
                object valObject = queryParameters [1];
                string val = valObject != null ? Uri.EscapeDataString(valObject.ToString()) : String.Empty;

                query.Append(key);
                query.Append('=');
                query.Append(val);
                query.Append('&');
            }

            return WithQuery(query.ToString());
        }

		/// <summary>
        /// Returns a <see cref="<#=PageClassName#>"/> object a specified query string attached. The object specified is an anonymous object.
        /// </summary>
        /// <param name="anonymousQueryStringSpecifier">The query parameters in the form of an anonymous object..</param>
        /// <returns></returns>
        public <#=PageClassName#> WithQuery(object anonymousQueryStringSpecifier) {
            return WithQuery(
                anonymousQueryStringSpecifier.GetType()
											<# if (IsProjectNet45()) {#>
											 .GetTypeInfo()
											 .GetRuntimeProperties()
											<# } else { #>
                                             .GetProperties()
											<# } #>
                                             .ToDictionary(p => p.Name, p => p.GetValue(anonymousQueryStringSpecifier, null)));
        }

        /// <summary>
        /// Returns a <see cref="<#=PageClassName#>"/> object with the specified query string attached. The query string is in format 
        /// of parameter=value&amp;parameter2=value2 and doesn't have to start with a question mark.
        /// </summary>
        /// <param name="queryString"></param>
        /// <returns></returns>
        public <#=PageClassName#> WithQuery(string queryString) {
            if (String.IsNullOrEmpty(queryString)) {
                return this;
            }

            if (queryString[0] != '?') {
                queryString = '?' + queryString;
            }

            return new <#=PageClassName#>(this.path + queryString);
        }

        /// <summary>
        /// Implements the operator ==.
        /// </summary>
        /// <param name="left">The left.</param>
        /// <param name="right">The right.</param>
        /// <returns>
        /// The result of the operator.
        /// </returns>
        public static bool operator == (<#=PageClassName#> left, <#=PageClassName#> right) {
            return Equals(left, right);
        }

        /// <summary>
        /// Implements the operator !=.
        /// </summary>
        /// <param name="left">The left.</param>
        /// <param name="right">The right.</param>
        /// <returns>
        /// The result of the operator.
        /// </returns>
        public static bool operator != (<#=PageClassName#> left, <#=PageClassName#> right) {
            return !Equals(left, right);
        }

        /// <summary>
        /// Performs an implicit conversion from <see cref="T4Navigation.Navigation.<#=PageClassName#>"/> to <see cref="System.String"/>.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator String(<#=PageClassName#> instance) {
            return instance == null ? null : instance.path;
        }

        /// <summary>
        /// Performs an implicit conversion from <see cref="T4Navigation.Navigation.<#=PageClassName#>"/> to <see cref="System.Uri"/>.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <returns>
        /// The result of the conversion.
        /// </returns>
        public static implicit operator Uri(<#=PageClassName#> instance) {
            return instance == null ? null : new Uri(instance.path, UriKind.Relative);
        }
    }
}

namespace <#=TryDetectProjectNamespace()#> {
	/// <summary>Provides strongly-typed navigation links</summary>
    [System.Diagnostics.DebuggerNonUserCodeAttribute]
	public static class NavigationDestination {
		
		<#GenerateForDirectory(currentDir);#>

	}
		
	
}

<#+
const string DefaultPageNamespace = "T4Navigation";
const string PageClassName = "_NavigationPageDestination";
static EnvDTE.Project CurrentProject; 

string TryDetectProjectNamespace() {
	return CurrentProject.Properties.Item("DefaultNamespace").Value.ToString();
}

bool IsProjectNet45() {
	Property targetFrameworkProp = CurrentProject.Properties.OfType<Property>().First(p => p.Name == "TargetFrameworkMoniker");
	string val = targetFrameworkProp.Value.ToString();

	const string versionString = "Version=";
	int idx = val.LastIndexOf(versionString) + versionString.Length + 1;
	val = val.Substring(idx);
	
	double frameworkVersion;
	if (double.TryParse(val, out frameworkVersion) && frameworkVersion >= 4.5) {
		return true;
    }

	return false;
}

void GenerateForDirectory(PageDirectory dir) {
	// navigation members
	foreach (string fileName in dir.Files) {
		string filePath = dir.RelativeDirPath + Path.AltDirectorySeparatorChar + fileName + ".xaml";
		
		GenerateNavigationMemberFor(fileName, filePath);
	}

	// child directories
	foreach (PageDirectory child in dir.Children) {#>
		/// <summary>Contains navigation links for pages in the directory '<#=child.Name#>' </summary>
		[System.Diagnostics.DebuggerNonUserCodeAttribute]
		public static class <#=child.Name#> {
			<#+GenerateForDirectory(child);#>
		}
		<#+
	}
}

void GenerateNavigationMemberFor(string fileName, string filePath) {
	#>
	/// <summary>Gets the navigation for '<#=filePath#>'</summary>
	public static readonly <#=PageClassName#> <#=fileName#> = new <#=PageClassName#>("<#=filePath#>");
	<#+
}

PageDirectory GeneratePageLinksForDirectory(string directoryPath) {
	IEnumerable<string> xamlFiles = Directory.EnumerateFiles(directoryPath, "*.xaml", SearchOption.TopDirectoryOnly);
	IEnumerable<string> directories = Directory.EnumerateDirectories(directoryPath, "*", SearchOption.TopDirectoryOnly);

	string directoryName = directoryPath.Substring(directoryPath.LastIndexOf(Path.DirectorySeparatorChar)+1);
	string projectRoot = Path.GetDirectoryName(CurrentProject.FullName);
	string relativeDirectory = directoryPath.Substring(projectRoot.Length).Replace(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar);
	bool currentPathIsProjectRoot = relativeDirectory.Length == 0;
	
	PageDirectory current = new PageDirectory(directoryName.Replace(".", ""), relativeDirectory);	

	// make sure to only retrieve xaml files with an associated code behind file: only those are actually pages
	// yes, we do assume here that PageName.xaml has at least PageName.xaml.cs
	foreach (string path in xamlFiles)
	{
		string filenameWithoutExt = Path.GetFileNameWithoutExtension(path);
		// TODO: just detect using the CurrentProject if it is a page
		// ignore app.xaml
		if (currentPathIsProjectRoot && filenameWithoutExt.ToLower() == "app") {
			continue;
		}

		// check for associated CS file
		string csharpFile = Path.Combine(Path.GetDirectoryName(path), filenameWithoutExt + ".xaml.cs");
		if (!File.Exists(csharpFile)) {
			continue;
		}

		// add to current object
		current.Files.Add(filenameWithoutExt);
	}

	// check for child dirs
	foreach (string childDirectoryPath in directories)
	{
		PageDirectory child = GeneratePageLinksForDirectory(childDirectoryPath);

		// ignore bin/obj directories at root
		if (currentPathIsProjectRoot && (childDirectoryPath.ToLower().EndsWith("bin") || childDirectoryPath.ToLower().EndsWith("obj"))) {
			continue;
		}

		if (child.AnyDescendantFiles) {
			current.Children.Add(child);
		}
	}

	return current;
}

class PageDirectory {
	public readonly string Name;

	public readonly string RelativeDirPath;

	public readonly List<string> Files;

	public readonly List<PageDirectory> Children;

	/// <summary>Gets if there are any files in this or descendant page directory objects</summary>
	public bool AnyDescendantFiles {
		get {
			Stack<PageDirectory> stck = new Stack<PageDirectory>();

			stck.Push(this);

			do {
				PageDirectory current = stck.Pop();

				// check files in current directory
				if (current.Files.Count > 0) {
					return true;
				}

				// check child dirs
				foreach (PageDirectory childObject in current.Children) {
					stck.Push(childObject);
				}
			} while (stck.Count > 0);

			return false;
		}
	}

	public PageDirectory(string name, string relativeDirectory) {
		Name = name;
		Children = new List<PageDirectory>();
		Files = new List<string>();
		RelativeDirPath = relativeDirectory;
	}
}

#>

